{"version":3,"sources":["models.ts","parsing.ts"],"names":[],"mappings":";AAaA,aAAA,IAAY,EAAZ,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,SAAY,GACV,EAAA,EAAA,MAAA,GAAA,QADF,CAAY,EAAA,QAAA,eAAA,QAAA,aAAY;;ACkGvB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA/GD,IAAA,EAAA,QAAA,YAEM,EAAiB,aACjB,EAAkB,iBAClB,EAAkB,gBAClB,EAAkB,uBAExB,SAAA,EAA8B,GAItB,IAHA,IAEF,EAFE,EAAW,GACX,EAAQ,EAAS,MAAM,MAEvB,EAAU,EAAa,IAClB,EAAA,KAAK,GAET,OAAA,EAGT,SAAA,EAAsB,GAEd,IADF,IAAA,EAA2B,KACzB,EAAM,OAAS,GAAG,CAChB,IAAA,EAAO,EAAM,QAChB,GAAC,EAAD,CAkBE,GAAgB,KAAhB,EAAK,OACN,MAGI,IAAA,EAAoB,EAAiB,GACxC,GAAA,EACO,EAAA,OAAS,EAAkB,WADlC,CAKG,IAAA,EAAW,EAAiB,GAC/B,GAAA,EACO,EAAA,UAAU,KAAK,OADtB,CAKG,IAAA,EAAW,EAAiB,GAC/B,GACO,EAAA,UAAU,KAAK,GAGjB,QAAA,KAAK,iBAAiB,SAvC7B,CAGE,GAAgB,KAAhB,EAAK,OACN,SAKC,KADO,EAAA,EAAgB,IAElB,MAAA,IAAI,MAAM,gCAAgC,GAE1C,EAAA,UAAY,GACZ,EAAA,UAAY,IA8BjB,OAAA,EAGT,SAAA,EAA0B,GAClB,IAAA,EAAQ,EAAK,MAAM,GACrB,GAAC,EAIE,MAAA,CACE,MAAA,EAAM,GACL,OAAA,EAAM,IAIlB,SAAA,EAAyB,GACjB,IAAA,EAAQ,EAAK,MAAM,GACrB,GAAC,EAIE,MAAA,CACC,KAAA,EAAM,IAIhB,SAAA,EAA0B,GAClB,IAAA,EAAQ,EAAK,MAAM,GACrB,GAAC,EAIE,MAAA,CACG,OAAA,EAAM,IAIlB,SAAA,EAA0B,GAClB,IAAA,EAAQ,EAAK,MAAM,GACtB,GAAC,EAIG,MAAA,CACC,KAAA,EAAA,aAAa,MACT,SAAA,EAAM,IAtGpB,QAAA,cAAA","file":"parsing.map","sourceRoot":"../src","sourcesContent":["\nexport interface Concept {\n  name: string;\n  parent?: string;\n  relations?: Relation[];\n  resources?: Resource[];\n}\n\nexport interface Resource {\n  type: ResourceType;\n  location: string;\n}\n\nexport enum ResourceType {\n  Image\n}\n\nexport interface Relation {\n  target: string;\n  label: string;\n}\n\nexport interface ContainsStatement {\n  parent: string;\n}\n","import { Concept, Relation, ContainsStatement, Resource, ResourceType } from \"./models\";\n\nconst ConceptPattern = /^([^\\s].+)/;\nconst RelationPattern = /\\s+<(.+)> (.+)/;\nconst ContainsPattern = /\\s+is in (.+)/;\nconst ResourcePattern = /\\s+has image at (.+)/\n\nexport function parseConcepts(document: string): Concept[] {\n  const concepts = [];\n  const lines = document.split('\\n');\n  let concept;\n  while(concept = parseConcept(lines)){\n    concepts.push(concept);\n  }\n  return concepts;\n}\n\nfunction parseConcept(lines: string[]): Concept | void {\n  let concept: Concept | void  = null;\n  while(lines.length > 0) {\n    const line = lines.shift();\n    if(!concept){\n\n      // scan\n      if(line.trim() === ''){\n        continue;\n      }\n\n      // first line should be concept\n      concept = tryParseConcept(line);\n      if(!concept){\n        throw new Error(`Could not parse concept from ${line}`);\n      }\n      concept.relations = [];\n      concept.resources = [];\n      continue;\n\n    } else {\n\n      if(line.trim() === ''){\n        break;\n      }\n\n      const containsStatement = tryParseContains(line);\n      if(containsStatement){\n        concept.parent = containsStatement.parent;\n        continue;\n      }\n\n      const relation = tryParseRelation(line);\n      if(relation){\n        concept.relations.push(relation);\n        continue;\n      }\n\n      const resource = tryParseResource(line);\n      if(resource){\n        concept.resources.push(resource);\n      }\n\n      console.warn(`Ignoring line ${line}`);\n    }\n\n  }\n  return concept;\n}\n\nfunction tryParseRelation(line: string): Relation | void {\n  const match = line.match(RelationPattern);\n  if (!match) {\n    return;\n  }\n\n  return {\n    label: match[1],\n    target: match[2]\n  };\n}\n\nfunction tryParseConcept(line: string): Concept | void {\n  const match = line.match(ConceptPattern);\n  if (!match) {\n    return;\n  }\n\n  return {\n    name: match[1]\n  };\n}\n\nfunction tryParseContains(line: string): ContainsStatement | void {\n  const match = line.match(ContainsPattern);\n  if (!match) {\n    return;\n  }\n\n  return {\n    parent: match[1]\n  };\n}\n\nfunction tryParseResource(line: string): Resource {\n  const match = line.match(ResourcePattern);\n  if(!match){\n    return;\n  }\n\n  return {\n    type: ResourceType.Image,\n    location: match[1]\n  };\n}\n"]}