{"version":3,"sources":["src/models.ts","src/parsing.ts","index.ts"],"names":[],"mappings":";AAaA,aAAA,IAAY,EAAZ,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,SAAY,GACV,EAAA,EAAA,MAAA,GAAA,QADF,CAAY,EAAA,QAAA,eAAA,QAAA,aAAY;;ACgHvB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA7HD,IAAA,EAAA,QAAA,YAEM,EAAiB,aACjB,EAAkB,iBAClB,EAAkB,gBAClB,EAAkB,uBAExB,SAAA,EAA8B,GAItB,IAHA,IAEF,EAFE,EAAW,GACX,EAAQ,EAAS,MAAM,MAEvB,EAAU,EAAa,IAClB,EAAA,KAAK,GAET,OAAA,EAGT,SAAA,EAAsB,GAKd,IAJF,IAAA,EAA0B,KACxB,EAAY,GACZ,EAAY,GAEZ,EAAM,OAAS,GAAG,CAChB,IAAA,EAAe,EAAM,SAAW,GACnC,GAAC,EAAD,CAgBE,GAAgB,KAAhB,EAAK,OACN,MAGI,IAAA,EAAoB,EAAiB,GACxC,GAAA,EACO,EAAA,OAAS,EAAkB,WADlC,CAKG,IAAA,EAAW,EAAiB,GAC/B,GAAA,EACS,EAAA,KAAK,OADd,CAKG,IAAA,EAAW,EAAiB,GAC/B,EACS,EAAA,KAAK,GAIT,QAAA,KAAK,iBAAiB,SAtC7B,CAGE,GAAgB,KAAhB,EAAK,OACN,SAKC,KADO,EAAA,EAAgB,IAElB,MAAA,IAAI,MAAM,gCAAgC,IAiCnD,OAAC,GAID,EAAU,OAAS,IACZ,EAAA,UAAY,GAEnB,EAAU,OAAS,IACZ,EAAA,UAAY,GAGf,GAVE,KAaX,SAAA,EAA0B,GAClB,IAAA,EAAQ,EAAK,MAAM,GACrB,GAAC,EAIE,MAAA,CACE,MAAA,EAAM,GACL,OAAA,EAAM,IAIlB,SAAA,EAAyB,GACjB,IAAA,EAAQ,EAAK,MAAM,GACrB,OAAC,EAIE,CACC,KAAA,EAAM,IAJL,KAQX,SAAA,EAA0B,GAClB,IAAA,EAAQ,EAAK,MAAM,GACrB,OAAC,EAIE,CACG,OAAA,EAAM,IAJP,KAQX,SAAA,EAA0B,GAClB,IAAA,EAAQ,EAAK,MAAM,GACtB,OAAC,EAIG,CACC,KAAA,EAAA,aAAa,MACT,SAAA,EAAM,IALT,KA/GX,QAAA,cAAA;;ACNS,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAT,IAAA,EAAA,QAAA,iBAAS,QAAA,cAAA,EAAA","file":"index.map","sourceRoot":"..","sourcesContent":["\nexport interface Concept {\n  name: string;\n  parent?: string;\n  relations?: Relation[];\n  resources?: Resource[];\n}\n\nexport interface Resource {\n  type: ResourceType;\n  location: string;\n}\n\nexport enum ResourceType {\n  Image\n}\n\nexport interface Relation {\n  target: string;\n  label: string;\n}\n\nexport interface ContainsStatement {\n  parent: string;\n}\n","import { Concept, Relation, ContainsStatement, Resource, ResourceType } from \"./models\";\n\nconst ConceptPattern = /^([^\\s].+)/;\nconst RelationPattern = /\\s+<(.+)> (.+)/;\nconst ContainsPattern = /\\s+is in (.+)/;\nconst ResourcePattern = /\\s+has image at (.+)/\n\nexport function parseConcepts(document: string): Concept[] {\n  const concepts = [];\n  const lines = document.split('\\n');\n  let concept;\n  while(concept = parseConcept(lines)){\n    concepts.push(concept);\n  }\n  return concepts;\n}\n\nfunction parseConcept(lines: string[]): Concept | null {\n  let concept: Concept | null = null;\n  const relations = [];\n  const resources = [];\n\n  while(lines.length > 0) {\n    const line: string = lines.shift() || '';\n    if(!concept){\n\n      // scan\n      if(line.trim() === ''){\n        continue;\n      }\n\n      // first line should be concept\n      concept = tryParseConcept(line);\n      if(!concept){\n        throw new Error(`Could not parse concept from ${line}`);\n      }\n      continue;\n\n    } else {\n\n      if(line.trim() === ''){\n        break;\n      }\n\n      const containsStatement = tryParseContains(line);\n      if(containsStatement){\n        concept.parent = containsStatement.parent;\n        continue;\n      }\n\n      const relation = tryParseRelation(line);\n      if(relation){\n        relations.push(relation);\n        continue;\n      }\n\n      const resource = tryParseResource(line);\n      if(resource){\n        resources.push(resource);\n        continue;\n      }\n\n      console.warn(`Ignoring line ${line}`);\n    }\n\n  }\n\n  if(!concept){\n    return null;\n  }\n\n  if(relations.length > 0){\n    concept.relations = relations;\n  }\n  if(resources.length > 0){\n    concept.resources = resources;\n  }\n\n  return concept;\n}\n\nfunction tryParseRelation(line: string): Relation | void {\n  const match = line.match(RelationPattern);\n  if (!match) {\n    return;\n  }\n\n  return {\n    label: match[1],\n    target: match[2]\n  };\n}\n\nfunction tryParseConcept(line: string): Concept | null {\n  const match = line.match(ConceptPattern);\n  if (!match) {\n    return null;\n  }\n\n  return {\n    name: match[1]\n  };\n}\n\nfunction tryParseContains(line: string): ContainsStatement | null {\n  const match = line.match(ContainsPattern);\n  if (!match) {\n    return null;\n  }\n\n  return {\n    parent: match[1]\n  };\n}\n\nfunction tryParseResource(line: string): Resource | null {\n  const match = line.match(ResourcePattern);\n  if(!match){\n    return null;\n  }\n\n  return {\n    type: ResourceType.Image,\n    location: match[1]\n  };\n}\n","\nexport { parseConcepts } from './src/parsing';\n"]}